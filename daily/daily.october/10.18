### 今日やること
* paiza Cランクメニューの残り loop文と前回までの苦手問題 1時間 ●
https://paiza.jp/works/mondai/c_rank_level_up_problems/problem_index?language_uid=ruby
* じゃんけん課題他の人のをコードリーディング 1時間 △
* 現場rails chapter3の復習 (CRUD機能にの実装について原理を自分で説明できるようになる) 1時間 ●
* デバックについて調べる 30分 ●
* practice課題 テーブル設計 ●


### 今日の学び
----byebugについて-----
byebugとは：
デバック作業をサポートしてくれるツールのこと。どこが原因でエラーが起きているのかを突き止めやすくしてくれる。
１行ごとにプログラムを実行してくれるので変数の中に格納されている値などをその都度確認できる。
使用方法：
byebugのgemをインストールして使用したいファイルでrequire 'byebug'で呼び出す。
デバックしたいコード部分にbyebugと書き込むことでその部分が読み込まれたときに
デバックモードが開始される。
コマンド例：
next       一行進む
continue   次のブレイクポイントに進む
step       メソッドの内部にステップインする
list       ソースコードを表示する
up         ソースコードの上を表示する
down       ソースコードの下を表示する



---paizaの問題について---

---for文 STEP1-----------------------------------------------------------------------------------------------
***入力***

***出力***

---自分の答案-------------------------------------------------------------------------------------------------
n = gets.to_i
m = gets.split(" ").map(&:to_i)
m.each do |x|
    count = 0
    if x % 3 == 0
        @count = count + 1
    end
end
    
p @count
---回答-------------------------------------------------------------------------------------------------------
n = gets.to_i
m = gets.split(" ").map(&:to_i)
@count = 0
m.each do |x|
    if x % 3 == 0
        @count = @count + 1
    end
end
    
p @count
---得られた学びpoint-----------------------------------------------------------------------------------------------
* スコープについて
スコープの話は定義されたメソッドの外でローカル変数を使うことができないという話。
今回のケースはメソッドを定義したdef count endの形ではなくeachの構文を使用している
だけなのでインスタンス変数を使用しなくてもローカル変数だけでやり取りをすることができる。
別解
n = gets.to_i
a = gets.split(' ').select { |n| n.to_i % 3 == 0 }

puts a.length
【 配列.select { |n| n.to_i%3==0 } について 】
Array クラスの select メソッドは配列の各要素に対してブロックの内容で評価して true になった全ての要素を持つ配列
を新たに生成して返します。


---for文 STEP2-----------------------------------------------------------------------------------------------

---自分の答案-------------------------------------------------------------------------------------------------
n = gets.to_i
m = gets.split(" ").map(&:to_i)
m.each do |x|
    if m.include? 7
        puts "YES" 
    else
        puts "NO"
    end
end
---回答-------------------------------------------------------------------------------------------------------
n = gets.to_i
a = Array.new(n)
n.times { |i| a[i] = gets.to_i }

exist = false
a.each do |num|
  if num == 7
    exist = true
    break
  end
end

if exist
  puts 'YES'
else
  puts 'NO'
end
---得られた学びpoint-----------------------------------------------------------------------------------------------
配列部分の作り方が間違っていた。



---for文 STEP3-----------------------------------------------------------------------------------------------
***入力***

***出力***

---自分の答案-------------------------------------------------------------------------------------------------
n = gets.to_i
arr = Array.new(n)
n.times |x|
 n[x] = gets.to_i
end
k = gets.to_i
---回答-------------------------------------------------------------------------------------------------------
n = gets.to_i

a = Array.new(n)
n.times { |i| a[i] = gets.to_i }

k = gets.to_i

n.times do |i|
  if a[i] == k
    puts i + 1
    break
  end
end
---得られた学びpoint-----------------------------------------------------------------------------------------------
times メソッドを用いて i=0 から i=n-1 まで a[i] == k を判定します。
a[i] == k のとき、i+1 を出力して break します
繰り返し文とif breakを組み合わせることで対象を見つけた時に処理を終了することができる。
while {条件} do
    # 処理
    if {条件}
        # 処理
        break
    end
end
https://techacademy.jp/magazine/19573


