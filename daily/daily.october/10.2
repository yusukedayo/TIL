### 今日の目標
* Practice ソートアルゴリズム完成
* Practice じゃんけんプログラム完成


### 今日の積み上げ
* ソート完成（プルリクまだ）
* じゃんけん完成（プルリクまだ）


##### * ブロックとは
 ブロックとはメソッドの引数として渡すことのできる処理の塊である。
 ブロック内で記述した処理は必要に応じてメソッドから呼び出せる。
 numbers.each do |n|
    sum += n
 end
上記のコードのdoからendまでがブロックと呼ばれる。 |n|はブロック引数と呼ばれeachメソッドから渡された配列の要素が入る。



##### * getについて
キーボードから値を入力してプログラムを実行するときに扱う。基本的にx = getsのように変数に入力したものを代入する形を取り、puts xで入力されたものを表示する。
注意点としては標準で末尾に改行がついているので文字列などに入力された値を代入しようとしてもずれが生じてしまうなのでgetsの後ろに「.chomp」をつけることで改行機能をなくせる。
gets = numの形だと入力されたものにnumを代入するということになってしまうのでundefindeのエラーが
numに対して発生していた。num = getsが正しい形。


##### * 配列からランダムな数値を１つ取り出す。
 配列を作成します。
 arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 配列から無作為に要素をひとつ選択します。
 ret = arr.sample
 p re




##### * while(繰り返し文)について
「while」文は指定した条件式が真(true)の間、繰り返し実行します。
 while 条件式 do
     実行する処理1
     実行する処理2
 end

##### * 基本的にコードは上から下に読み込まれる。メソッドも作ってから呼び出すが上下の形にちゃんとなっているか確認する。

##### * 今日起きたエラーについて
 if説で条件分離を作り時に今回のようなじゃんけんの場合だと勝ちと負けあいこがあって
 勝ち・負け両方の条件分離は書くのがめんどくさいのに比べてあいこは手が一緒になった時だけだから
 あいこと勝ちで条件作って負けはelseで書いてあげると楽。少ないコード量書くためにどの条件をelseにしたらよいか考えるべき。

     cards = ["g", "c", "p"]
     @cpu = cards.sample
 def battle
     puts "じゃんけん（g, c, pから選択してください）"
     @user = gets.chomp
     puts "CPU #{@cpu}"
     puts "あなた #{@user}"
     if @user == @cpu
         puts "あいこ"
         return true
     elsif  (@user == "g" && @cpu == "c") || (@user == "c" && @cpu == "p") || (@user == "p" && @cpu == "g")
         puts "あなたの勝ち"
         return false
     else 
         puts "あなたの負け"
         return false
     end
 end
 next_game = true
 while next_game do
     next_game = battle
 end
 上記の状態でじゃんけんをするとあいこで相手がずっと同じ手を出してくる問題が発生した。原因はwhileの指定範囲であった。
 whileではbattleが繰り返しの対象なのでその外で相手の手を決めってしまうと最初の手で固定したものを繰り返してしまう。どの部分を繰り返しているのかは注意が必要である。

- - -

##### * 今日起きたエラーについて
下記のコードでずっとbad～のエラーが出ていた。
原因はAGRVで受け取った数値が文字列のままだったので(1..number)の部分で数値と文字列が混合してしまいエラーとなっていた。
このエラーの原因を見つけられたのはやはり分割してコードを考えたことである。
nunberに数値を入れた時点でちゃんとコマンドからの数値がputsされるのかなど細かく見ていると原因に気づけた。
やはり、コード全体を見るのではなくコードを段階的に分けて「どこまでできていてどこからできないのかを明確にする」ことがとても大切。
number = ARGV[0]

    (1..number).each do |x|
        if x % 15 == 0
            puts "FizzBuzz"
        elsif x % 5 == 0
            puts "Buzz"
        elsif x % 3 == 0
            puts "Fizz"
        else
            puts x
        end
    end






